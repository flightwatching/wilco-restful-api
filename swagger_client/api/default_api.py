# coding: utf-8

"""
    WILCO API

    This  API allows you to pull and push data with your WILCO deployment [https://github.com/flightwatching/wilco-api](https://github.com/flightwatching/wilco-api) or on  [www.flightwatching.com](www.flightwatching.com).   # noqa: E501

    OpenAPI spec version: 3.0.0
    Contact: contact@flightwatching.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_analysis(self, event_id, **kwargs):  # noqa: E501
        """create an analysis from the event passed. should use insert message. see https://github.com/flightwatching/fleet-monitor/issues/55  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_analysis(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str content: the sumUp
        :param int rule_id: the id of the rule that has trigged the creation
        :param str fault_code: the fault code if the analysis is linked to a fault code
        :param datetime d: the date where the analysis has to locate. if not set, the event computed date is used
        :param str severity: the severity of the analysis
        :param str flight_phase: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_analysis_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_analysis_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def create_analysis_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """create an analysis from the event passed. should use insert message. see https://github.com/flightwatching/fleet-monitor/issues/55  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_analysis_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str content: the sumUp
        :param int rule_id: the id of the rule that has trigged the creation
        :param str fault_code: the fault code if the analysis is linked to a fault code
        :param datetime d: the date where the analysis has to locate. if not set, the event computed date is used
        :param str severity: the severity of the analysis
        :param str flight_phase: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'content', 'rule_id', 'fault_code', 'd', 'severity', 'flight_phase']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `create_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'content' in params:
            query_params.append(('content', params['content']))  # noqa: E501
        if 'rule_id' in params:
            query_params.append(('ruleId', params['rule_id']))  # noqa: E501
        if 'fault_code' in params:
            query_params.append(('faultCode', params['fault_code']))  # noqa: E501
        if 'd' in params:
            query_params.append(('d', params['d']))  # noqa: E501
        if 'severity' in params:
            query_params.append(('severity', params['severity']))  # noqa: E501
        if 'flight_phase' in params:
            query_params.append(('flightPhase', params['flight_phase']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/createAnalysis', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dashboard(self, **kwargs):  # noqa: E501
        """creates the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dashboard_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_dashboard_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_dashboard_with_http_info(self, **kwargs):  # noqa: E501
        """creates the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dashboard" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dashboard_rule(self, dbid, **kwargs):  # noqa: E501
        """creates a dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard_rule(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dashboard_rule_with_http_info(dbid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dashboard_rule_with_http_info(dbid, **kwargs)  # noqa: E501
            return data

    def create_dashboard_rule_with_http_info(self, dbid, **kwargs):  # noqa: E501
        """creates a dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard_rule_with_http_info(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dbid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dashboard_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dbid' is set
        if ('dbid' not in params or
                params['dbid'] is None):
            raise ValueError("Missing the required parameter `dbid` when calling `create_dashboard_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dbid' in params:
            path_params['dbid'] = params['dbid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{dbid}/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dashboard_svg(self, dbid, **kwargs):  # noqa: E501
        """Returns the SVG for a dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard_svg(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dashboard_svg_with_http_info(dbid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dashboard_svg_with_http_info(dbid, **kwargs)  # noqa: E501
            return data

    def create_dashboard_svg_with_http_info(self, dbid, **kwargs):  # noqa: E501
        """Returns the SVG for a dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard_svg_with_http_info(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dbid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dashboard_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dbid' is set
        if ('dbid' not in params or
                params['dbid'] is None):
            raise ValueError("Missing the required parameter `dbid` when calling `create_dashboard_svg`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dbid' in params:
            path_params['dbid'] = params['dbid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{dbid}/svg', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dashboard_symbols(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard_symbols(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_dashboard_symbols_with_http_info(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dashboard_symbols_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dashboard_symbols" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_event(self, **kwargs):  # noqa: E501
        """creates an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_event(async=True)
        >>> result = thread.get()

        :param async bool
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_event_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_event_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_event_with_http_info(self, **kwargs):  # noqa: E501
        """creates an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_event_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_event" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_event_samples(self, event_id, **kwargs):  # noqa: E501
        """Returns the samples of an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_event_samples(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param str format:   or json. default is json
        :param datetime _from: the min date for the sample
        :param datetime to: the max date for the sample
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_event_samples_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_event_samples_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def create_event_samples_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Returns the samples of an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_event_samples_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param str format:   or json. default is json
        :param datetime _from: the min date for the sample
        :param datetime to: the max date for the sample
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'category', 'reg', 'format', '_from', 'to']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_event_samples" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `create_event_samples`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/samples', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_faultcode(self, **kwargs):  # noqa: E501
        """Creates a fault code from the body  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_faultcode(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_faultcode_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_faultcode_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_faultcode_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a fault code from the body  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_faultcode_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_faultcode" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/faultcodes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IftV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_fwot(self, **kwargs):  # noqa: E501
        """Returns all the fwots paginated. If the connected user has an airline, the list is filtered for this airline  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_fwot(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_fwot_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_fwot_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_fwot_with_http_info(self, **kwargs):  # noqa: E501
        """Returns all the fwots paginated. If the connected user has an airline, the list is filtered for this airline  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_fwot_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fwot" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/fwots', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FwotV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_fwot_property(self, plural_category, reg, name, **kwargs):  # noqa: E501
        """add a new property to the fwot. If null passed in the value arg, the prop is removed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_fwot_property(plural_category, reg, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param str name: the name of the property (required)
        :param str value: the value of the property. if null, the prop is removed
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_fwot_property_with_http_info(plural_category, reg, name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_fwot_property_with_http_info(plural_category, reg, name, **kwargs)  # noqa: E501
            return data

    def create_fwot_property_with_http_info(self, plural_category, reg, name, **kwargs):  # noqa: E501
        """add a new property to the fwot. If null passed in the value arg, the prop is removed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_fwot_property_with_http_info(plural_category, reg, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param str name: the name of the property (required)
        :param str value: the value of the property. if null, the prop is removed
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'name', 'value']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fwot_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `create_fwot_property`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `create_fwot_property`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_fwot_property`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/property', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_layout(self, layout_id, **kwargs):  # noqa: E501
        """modifies a layout stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_layout(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_layout_with_http_info(layout_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_layout_with_http_info(layout_id, **kwargs)  # noqa: E501
            return data

    def create_layout_with_http_info(self, layout_id, **kwargs):  # noqa: E501
        """modifies a layout stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_layout_with_http_info(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['layout_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_layout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'layout_id' is set
        if ('layout_id' not in params or
                params['layout_id'] is None):
            raise ValueError("Missing the required parameter `layout_id` when calling `create_layout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'layout_id' in params:
            path_params['layoutId'] = params['layout_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/{layoutId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_layout_event(self, event_id, **kwargs):  # noqa: E501
        """Creates a layout from a message  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_layout_event(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event from which we create the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_layout_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_layout_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def create_layout_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Creates a layout from a message  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_layout_event_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event from which we create the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_layout_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `create_layout_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/layout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_layouts(self, **kwargs):  # noqa: E501
        """Returns list of layouts stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_layouts(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :param str contains: the layout name part to filter on
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_layouts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_layouts_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_layouts_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of layouts stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_layouts_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :param str contains: the layout name part to filter on
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'count', 'contains']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_layouts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_parameters(self, **kwargs):  # noqa: E501
        """Returns the parameters for the given search string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_parameters(async=True)
        >>> result = thread.get()

        :param async bool
        :param str contains: the parameter name part to filter on
        :param bool detailled: Do we return the head (false&default) or the complete description?
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_parameters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_parameters_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_parameters_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the parameters for the given search string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_parameters_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str contains: the parameter name part to filter on
        :param bool detailled: Do we return the head (false&default) or the complete description?
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contains', 'detailled', 'page', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_parameters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501
        if 'detailled' in params:
            query_params.append(('detailled', params['detailled']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_simulate_push_pull(self, pull_layout_id, **kwargs):  # noqa: E501
        """Calls the URL service and simulates the call to the IFT with the returned content in the right variable. In the body you will need a json structure {formula:&#39;&lt;the formula&gt;&#39;}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_simulate_push_pull(pull_layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int pull_layout_id: the id of the pull layout (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_simulate_push_pull_with_http_info(pull_layout_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_simulate_push_pull_with_http_info(pull_layout_id, **kwargs)  # noqa: E501
            return data

    def create_simulate_push_pull_with_http_info(self, pull_layout_id, **kwargs):  # noqa: E501
        """Calls the URL service and simulates the call to the IFT with the returned content in the right variable. In the body you will need a json structure {formula:&#39;&lt;the formula&gt;&#39;}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_simulate_push_pull_with_http_info(pull_layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int pull_layout_id: the id of the pull layout (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pull_layout_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_simulate_push_pull" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pull_layout_id' is set
        if ('pull_layout_id' not in params or
                params['pull_layout_id'] is None):
            raise ValueError("Missing the required parameter `pull_layout_id` when calling `create_simulate_push_pull`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pull_layout_id' in params:
            path_params['pullLayoutId'] = params['pull_layout_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/{pullLayoutId}/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_symbol(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_symbol(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
            return data

    def create_symbol_with_http_info(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_symbol_with_http_info(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_symbol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol_id' is set
        if ('symbol_id' not in params or
                params['symbol_id'] is None):
            raise ValueError("Missing the required parameter `symbol_id` when calling `create_symbol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'symbol_id' in params:
            path_params['symbolId'] = params['symbol_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols/{symbolId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_symbol_svg_example(self, symbol_id, **kwargs):  # noqa: E501
        """Returns the SVG example for a symbol  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_symbol_svg_example(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_symbol_svg_example_with_http_info(symbol_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_symbol_svg_example_with_http_info(symbol_id, **kwargs)  # noqa: E501
            return data

    def create_symbol_svg_example_with_http_info(self, symbol_id, **kwargs):  # noqa: E501
        """Returns the SVG example for a symbol  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_symbol_svg_example_with_http_info(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_symbol_svg_example" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol_id' is set
        if ('symbol_id' not in params or
                params['symbol_id'] is None):
            raise ValueError("Missing the required parameter `symbol_id` when calling `create_symbol_svg_example`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'symbol_id' in params:
            path_params['symbolId'] = params['symbol_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols/{symbolId}/svgExample', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_test_ift(self, **kwargs):  # noqa: E501
        """returns the logs for simulating the passed formula against past evtId. In the body you will need a json structure {formula:&#39;&lt;the formula&gt;&#39;, msgId:3652, language:JS_NODEJS}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_test_ift(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_test_ift_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_test_ift_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_test_ift_with_http_info(self, **kwargs):  # noqa: E501
        """returns the logs for simulating the passed formula against past evtId. In the body you will need a json structure {formula:&#39;&lt;the formula&gt;&#39;, msgId:3652, language:JS_NODEJS}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_test_ift_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_test_ift" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/ifts/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IftV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_toggle_event(self, event_id, **kwargs):  # noqa: E501
        """Updates an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_toggle_event(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_toggle_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_toggle_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def create_toggle_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Updates an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_toggle_event_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_toggle_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `create_toggle_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/toggle', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_toggle_event1(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Updates an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_toggle_event1(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_toggle_event1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_toggle_event1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def create_toggle_event1_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Updates an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_toggle_event1_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_toggle_event1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `create_toggle_event1`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `create_toggle_event1`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `create_toggle_event1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/toggle', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_trends(self, **kwargs):  # noqa: E501
        """Returns list of trends stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_trends(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_trends_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_trends_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_trends_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of trends stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_trends_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_trends" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/trendbundles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrendBundleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_uplink(self, reg, layout_id, **kwargs):  # noqa: E501
        """uplink the with the layout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_uplink(reg, layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str reg: the registration of the fwot (required)
        :param int layout_id: the ID of the layout to uplink (required)
        :param int delay: delay in seconds before the actual uplink
        :param int rule_id: the id of the rule that trigged the uplink. if null, the user is considered
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_uplink_with_http_info(reg, layout_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_uplink_with_http_info(reg, layout_id, **kwargs)  # noqa: E501
            return data

    def create_uplink_with_http_info(self, reg, layout_id, **kwargs):  # noqa: E501
        """uplink the with the layout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_uplink_with_http_info(reg, layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str reg: the registration of the fwot (required)
        :param int layout_id: the ID of the layout to uplink (required)
        :param int delay: delay in seconds before the actual uplink
        :param int rule_id: the id of the rule that trigged the uplink. if null, the user is considered
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reg', 'layout_id', 'delay', 'rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_uplink" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `create_uplink`")  # noqa: E501
        # verify the required parameter 'layout_id' is set
        if ('layout_id' not in params or
                params['layout_id'] is None):
            raise ValueError("Missing the required parameter `layout_id` when calling `create_uplink`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'layout_id' in params:
            path_params['layoutId'] = params['layout_id']  # noqa: E501

        query_params = []
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'delay' in params:
            query_params.append(('delay', params['delay']))  # noqa: E501
        if 'rule_id' in params:
            query_params.append(('ruleId', params['rule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/{layoutId}/uplink', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_uplink_same(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """uplink the fwot to get the same message as the event passed.uplinks only if the event has an uplinkable layout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_uplink_same(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_uplink_same_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_uplink_same_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def create_uplink_same_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """uplink the fwot to get the same message as the event passed.uplinks only if the event has an uplinkable layout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_uplink_same_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_uplink_same" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `create_uplink_same`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `create_uplink_same`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `create_uplink_same`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/uplinkSame', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_webhook(self, webhook_id, **kwargs):  # noqa: E501
        """endpoint for push layouts webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_webhook(webhook_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str webhook_id: the uuid of the hook (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501
            return data

    def create_webhook_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        """endpoint for push layouts webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_webhook_with_http_info(webhook_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str webhook_id: the uuid of the hook (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['webhook_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_webhook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'webhook_id' is set
        if ('webhook_id' not in params or
                params['webhook_id'] is None):
            raise ValueError("Missing the required parameter `webhook_id` when calling `create_webhook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'webhook_id' in params:
            path_params['webhookId'] = params['webhook_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/webhook/{webhookId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dashboard_rule(self, dbid, id, **kwargs):  # noqa: E501
        """deletes the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dashboard_rule(dbid, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :param int id: the id of the dashboard rule (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dashboard_rule_with_http_info(dbid, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dashboard_rule_with_http_info(dbid, id, **kwargs)  # noqa: E501
            return data

    def delete_dashboard_rule_with_http_info(self, dbid, id, **kwargs):  # noqa: E501
        """deletes the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dashboard_rule_with_http_info(dbid, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :param int id: the id of the dashboard rule (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dbid', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dashboard_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dbid' is set
        if ('dbid' not in params or
                params['dbid'] is None):
            raise ValueError("Missing the required parameter `dbid` when calling `delete_dashboard_rule`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_dashboard_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dbid' in params:
            path_params['dbid'] = params['dbid']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{dbid}/rules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dashboard_symbols(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dashboard_symbols(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_dashboard_symbols_with_http_info(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dashboard_symbols_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dashboard_symbols" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dashboards_dbid(self, dbid, **kwargs):  # noqa: E501
        """trashes the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dashboards_dbid(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dashboards_dbid_with_http_info(dbid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dashboards_dbid_with_http_info(dbid, **kwargs)  # noqa: E501
            return data

    def delete_dashboards_dbid_with_http_info(self, dbid, **kwargs):  # noqa: E501
        """trashes the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dashboards_dbid_with_http_info(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dbid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dashboards_dbid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dbid' is set
        if ('dbid' not in params or
                params['dbid'] is None):
            raise ValueError("Missing the required parameter `dbid` when calling `delete_dashboards_dbid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dbid' in params:
            path_params['dbid'] = params['dbid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{dbid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_event(self, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_event(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def delete_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_event_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'category', 'reg', 'nested']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `delete_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'nested' in params:
            query_params.append(('nested', params['nested']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_layout(self, layout_id, **kwargs):  # noqa: E501
        """marks a layout as trashed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_layout(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_layout_with_http_info(layout_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_layout_with_http_info(layout_id, **kwargs)  # noqa: E501
            return data

    def delete_layout_with_http_info(self, layout_id, **kwargs):  # noqa: E501
        """marks a layout as trashed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_layout_with_http_info(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['layout_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_layout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'layout_id' is set
        if ('layout_id' not in params or
                params['layout_id'] is None):
            raise ValueError("Missing the required parameter `layout_id` when calling `delete_layout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'layout_id' in params:
            path_params['layoutId'] = params['layout_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/{layoutId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_parameter(self, id, **kwargs):  # noqa: E501
        """returns a parameter. You can PUT or GET. DELETE not yet supported  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_parameter(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the parameters to filter on. (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_parameter_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_parameter_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_parameter_with_http_info(self, id, **kwargs):  # noqa: E501
        """returns a parameter. You can PUT or GET. DELETE not yet supported  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_parameter_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the parameters to filter on. (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_parameter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_parameter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_symbol(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_symbol(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
            return data

    def delete_symbol_with_http_info(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_symbol_with_http_info(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_symbol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol_id' is set
        if ('symbol_id' not in params or
                params['symbol_id'] is None):
            raise ValueError("Missing the required parameter `symbol_id` when calling `delete_symbol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'symbol_id' in params:
            path_params['symbolId'] = params['symbol_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols/{symbolId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_trend(self, bundle_id, **kwargs):  # noqa: E501
        """get, update or delete a trend  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_trend(bundle_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bundle_id: the id of the bundle (required)
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_trend_with_http_info(bundle_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_trend_with_http_info(bundle_id, **kwargs)  # noqa: E501
            return data

    def delete_trend_with_http_info(self, bundle_id, **kwargs):  # noqa: E501
        """get, update or delete a trend  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_trend_with_http_info(bundle_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bundle_id: the id of the bundle (required)
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bundle_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_trend" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bundle_id' is set
        if ('bundle_id' not in params or
                params['bundle_id'] is None):
            raise ValueError("Missing the required parameter `bundle_id` when calling `delete_trend`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bundle_id' in params:
            path_params['bundleId'] = params['bundle_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/trendbundles/{bundleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrendBundleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_admin_links(self, **kwargs):  # noqa: E501
        """returns a list of links to admin features  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_admin_links(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_admin_links_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_admin_links_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_admin_links_with_http_info(self, **kwargs):  # noqa: E501
        """returns a list of links to admin features  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_admin_links_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_links" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/adminLinks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_blocking_listen(self, **kwargs):  # noqa: E501
        """The method blocks until something happends in the message queue: creation, new message, fault, rule detected something, user did something (manual close, clear, recall warning...). no more than 100 messages from the after parameter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_blocking_listen(async=True)
        >>> result = thread.get()

        :param async bool
        :param int after: the timestamp after which we want the elements. if no value, use current time
        :param int block_duration: how many seconds this method blocks before releasing if no event. if no value, blocks 10s
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_blocking_listen_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_blocking_listen_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_blocking_listen_with_http_info(self, **kwargs):  # noqa: E501
        """The method blocks until something happends in the message queue: creation, new message, fault, rule detected something, user did something (manual close, clear, recall warning...). no more than 100 messages from the after parameter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_blocking_listen_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int after: the timestamp after which we want the elements. if no value, use current time
        :param int block_duration: how many seconds this method blocks before releasing if no event. if no value, blocks 10s
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['after', 'block_duration']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_blocking_listen" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'block_duration' in params:
            query_params.append(('blockDuration', params['block_duration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/listenNewMessages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bookmark(self, bookmark, **kwargs):  # noqa: E501
        """Returns the bookmark image  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bookmark(bookmark, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bookmark: the id of the bookmark (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bookmark_with_http_info(bookmark, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bookmark_with_http_info(bookmark, **kwargs)  # noqa: E501
            return data

    def get_bookmark_with_http_info(self, bookmark, **kwargs):  # noqa: E501
        """Returns the bookmark image  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bookmark_with_http_info(bookmark, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bookmark: the id of the bookmark (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bookmark']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bookmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bookmark' is set
        if ('bookmark' not in params or
                params['bookmark'] is None):
            raise ValueError("Missing the required parameter `bookmark` when calling `get_bookmark`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bookmark' in params:
            path_params['bookmark'] = params['bookmark']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/bookmarks/{bookmark}/photo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bookmarks(self, **kwargs):  # noqa: E501
        """Returns list of bookmarks stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bookmarks(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BookmarkV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bookmarks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_bookmarks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_bookmarks_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of bookmarks stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bookmarks_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BookmarkV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bookmarks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/bookmarks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BookmarkV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_categories(self, **kwargs):  # noqa: E501
        """Returns all the categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_categories(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_categories_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_categories_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_categories_with_http_info(self, **kwargs):  # noqa: E501
        """Returns all the categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_categories_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_categories" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config(self, **kwargs):  # noqa: E501
        """check the status of the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_config_with_http_info(self, **kwargs):  # noqa: E501
        """check the status of the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_constants(self, **kwargs):  # noqa: E501
        """Returns all the constants  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_constants(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ConstantV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_constants_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_constants_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_constants_with_http_info(self, **kwargs):  # noqa: E501
        """Returns all the constants  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_constants_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ConstantV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_constants" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/constants', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstantV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard(self, id, **kwargs):  # noqa: E501
        """Returns the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the dashboard (required)
        :return: DashboardV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dashboard_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_with_http_info(self, id, **kwargs):  # noqa: E501
        """Returns the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the dashboard (required)
        :return: DashboardV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_rule(self, id, **kwargs):  # noqa: E501
        """Returns the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_rule(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the dashboard rule (required)
        :param int dbid: the id of the dashboard
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dashboard_rule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_rule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_rule_with_http_info(self, id, **kwargs):  # noqa: E501
        """Returns the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_rule_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the dashboard rule (required)
        :param int dbid: the id of the dashboard
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'dbid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'dbid' in params:
            query_params.append(('dbid', params['dbid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/rules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_rule1(self, dbid, id, **kwargs):  # noqa: E501
        """Returns the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_rule1(dbid, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :param int id: the id of the dashboard rule (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dashboard_rule1_with_http_info(dbid, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_rule1_with_http_info(dbid, id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_rule1_with_http_info(self, dbid, id, **kwargs):  # noqa: E501
        """Returns the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_rule1_with_http_info(dbid, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :param int id: the id of the dashboard rule (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dbid', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_rule1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dbid' is set
        if ('dbid' not in params or
                params['dbid'] is None):
            raise ValueError("Missing the required parameter `dbid` when calling `get_dashboard_rule1`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard_rule1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dbid' in params:
            path_params['dbid'] = params['dbid']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{dbid}/rules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_svg(self, dbid, **kwargs):  # noqa: E501
        """Returns the SVG for a dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_svg(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dashboard_svg_with_http_info(dbid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_svg_with_http_info(dbid, **kwargs)  # noqa: E501
            return data

    def get_dashboard_svg_with_http_info(self, dbid, **kwargs):  # noqa: E501
        """Returns the SVG for a dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_svg_with_http_info(dbid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dbid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_svg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dbid' is set
        if ('dbid' not in params or
                params['dbid'] is None):
            raise ValueError("Missing the required parameter `dbid` when calling `get_dashboard_svg`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dbid' in params:
            path_params['dbid'] = params['dbid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{dbid}/svg', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_symbols(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_symbols(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dashboard_symbols_with_http_info(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dashboard_symbols_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_symbols" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event(self, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def get_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'category', 'reg', 'nested']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'nested' in params:
            query_params.append(('nested', params['nested']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event1(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event1(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def get_event1_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event1_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id', 'nested']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_event1`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_event1`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'nested' in params:
            query_params.append(('nested', params['nested']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_param(self, event_id, name, **kwargs):  # noqa: E501
        """Returns param for this name, in this event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_param(event_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str name: the name of the param (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event_param_with_http_info(event_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_param_with_http_info(event_id, name, **kwargs)  # noqa: E501
            return data

    def get_event_param_with_http_info(self, event_id, name, **kwargs):  # noqa: E501
        """Returns param for this name, in this event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_param_with_http_info(event_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str name: the name of the param (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'name', 'category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_param" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event_param`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_event_param`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/parameters/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_param1(self, plural_category, reg, event_id, name, **kwargs):  # noqa: E501
        """Returns param for this name, in this event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_param1(plural_category, reg, event_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param str name: the name of the param (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event_param1_with_http_info(plural_category, reg, event_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_param1_with_http_info(plural_category, reg, event_id, name, **kwargs)  # noqa: E501
            return data

    def get_event_param1_with_http_info(self, plural_category, reg, event_id, name, **kwargs):  # noqa: E501
        """Returns param for this name, in this event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_param1_with_http_info(plural_category, reg, event_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param str name: the name of the param (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_param1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_event_param1`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_event_param1`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event_param1`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_event_param1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/parameters/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_params(self, event_id, **kwargs):  # noqa: E501
        """Returns the params involved in an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_params(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param str name: the name of the param
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event_params_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_params_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def get_event_params_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Returns the params involved in an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_params_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param str name: the name of the param
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'category', 'reg', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_params" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event_params`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/parameters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_params1(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the params involved in an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_params1(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param str name: the name of the param
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event_params1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_params1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def get_event_params1_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the params involved in an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_params1_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param str name: the name of the param
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_params1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_event_params1`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_event_params1`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event_params1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/parameters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_samples(self, event_id, **kwargs):  # noqa: E501
        """Returns the samples of an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_samples(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param str format:   or json. default is json
        :param datetime _from: the min date for the sample
        :param datetime to: the max date for the sample
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event_samples_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_samples_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def get_event_samples_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Returns the samples of an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_samples_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param str format:   or json. default is json
        :param datetime _from: the min date for the sample
        :param datetime to: the max date for the sample
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'category', 'reg', 'format', '_from', 'to']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_samples" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event_samples`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/samples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_samples1(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the samples of an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_samples1(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param str format:   or json. default is json
        :param datetime _from: the min date for the sample
        :param datetime to: the max date for the sample
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_event_samples1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_samples1_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def get_event_samples1_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the samples of an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_event_samples1_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param str format:   or json. default is json
        :param datetime _from: the min date for the sample
        :param datetime to: the max date for the sample
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id', 'format', '_from', 'to']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_samples1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_event_samples1`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_event_samples1`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event_samples1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/samples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_faultcodes(self, **kwargs):  # noqa: E501
        """Returns the fault codes for the given fwot type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_faultcodes(async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the fwot type
        :param str prefix: the faultcode prefix (eg ATA)
        :param int page: the page. starts #1
        :param int count: the max count of faultcodes
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_faultcodes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_faultcodes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_faultcodes_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the fault codes for the given fwot type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_faultcodes_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the fwot type
        :param str prefix: the faultcode prefix (eg ATA)
        :param int page: the page. starts #1
        :param int count: the max count of faultcodes
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['actype', 'prefix', 'page', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_faultcodes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'actype' in params:
            query_params.append(('actype', params['actype']))  # noqa: E501
        if 'prefix' in params:
            query_params.append(('prefix', params['prefix']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/faultcodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IftV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fwot(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns the fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_fwot_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fwot_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def get_fwot_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns the fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fwot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_fwot`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_fwot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FwotV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fwot_events(self, **kwargs):  # noqa: E501
        """Returns some events of an fwot according to some filters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot_events(async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param datetime _from: the date from which we want to get the events (strict gt -> does not include exact same date
        :param datetime to: the date to which we want to get the events (strict lt -> does not include exact same date
        :param bool with_dismissed: show the dismissed events
        :param bool show_hidden: show the non visible events
        :param bool important: only important events
        :param str sev: only important events
        :param str tag: only events matching the given tag. Can have several tags in the request
        :param int count: the max count of messages
        :param int after: the timestamp after which we want the elements
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_fwot_events_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_fwot_events_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_fwot_events_with_http_info(self, **kwargs):  # noqa: E501
        """Returns some events of an fwot according to some filters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot_events_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param datetime _from: the date from which we want to get the events (strict gt -> does not include exact same date
        :param datetime to: the date to which we want to get the events (strict lt -> does not include exact same date
        :param bool with_dismissed: show the dismissed events
        :param bool show_hidden: show the non visible events
        :param bool important: only important events
        :param str sev: only important events
        :param str tag: only events matching the given tag. Can have several tags in the request
        :param int count: the max count of messages
        :param int after: the timestamp after which we want the elements
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category', 'reg', '_from', 'to', 'with_dismissed', 'show_hidden', 'important', 'sev', 'tag', 'count', 'after']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fwot_events" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'with_dismissed' in params:
            query_params.append(('withDismissed', params['with_dismissed']))  # noqa: E501
        if 'show_hidden' in params:
            query_params.append(('showHidden', params['show_hidden']))  # noqa: E501
        if 'important' in params:
            query_params.append(('important', params['important']))  # noqa: E501
        if 'sev' in params:
            query_params.append(('sev', params['sev']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fwot_events1(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns some events of an fwot according to some filters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot_events1(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param datetime _from: the date from which we want to get the events (strict gt -> does not include exact same date
        :param datetime to: the date to which we want to get the events (strict lt -> does not include exact same date
        :param bool with_dismissed: show the dismissed events
        :param bool show_hidden: show the non visible events
        :param bool important: only important events
        :param str sev: only important events
        :param str tag: only events matching the given tag. Can have several tags in the request
        :param int count: the max count of messages
        :param int after: the timestamp after which we want the elements
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_fwot_events1_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fwot_events1_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def get_fwot_events1_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns some events of an fwot according to some filters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot_events1_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param datetime _from: the date from which we want to get the events (strict gt -> does not include exact same date
        :param datetime to: the date to which we want to get the events (strict lt -> does not include exact same date
        :param bool with_dismissed: show the dismissed events
        :param bool show_hidden: show the non visible events
        :param bool important: only important events
        :param str sev: only important events
        :param str tag: only events matching the given tag. Can have several tags in the request
        :param int count: the max count of messages
        :param int after: the timestamp after which we want the elements
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', '_from', 'to', 'with_dismissed', 'show_hidden', 'important', 'sev', 'tag', 'count', 'after']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fwot_events1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_fwot_events1`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_fwot_events1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'with_dismissed' in params:
            query_params.append(('withDismissed', params['with_dismissed']))  # noqa: E501
        if 'show_hidden' in params:
            query_params.append(('showHidden', params['show_hidden']))  # noqa: E501
        if 'important' in params:
            query_params.append(('important', params['important']))  # noqa: E501
        if 'sev' in params:
            query_params.append(('sev', params['sev']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fwot_image(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns the fwot image  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot_image(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_fwot_image_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fwot_image_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def get_fwot_image_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns the fwot image  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwot_image_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fwot_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_fwot_image`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_fwot_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/photo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fwots(self, plural_category, **kwargs):  # noqa: E501
        """Returns all the fwots paginated. If the connected user has an airline, the list is filtered for this airline  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwots(plural_category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_fwots_with_http_info(plural_category, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fwots_with_http_info(plural_category, **kwargs)  # noqa: E501
            return data

    def get_fwots_with_http_info(self, plural_category, **kwargs):  # noqa: E501
        """Returns all the fwots paginated. If the connected user has an airline, the list is filtered for this airline  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwots_with_http_info(plural_category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'page', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fwots" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_fwots`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FwotV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fwots1(self, category, **kwargs):  # noqa: E501
        """Returns all the fwots paginated. If the connected user has an airline, the list is filtered for this airline  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwots1(category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: the category of the fwot (required)
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_fwots1_with_http_info(category, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fwots1_with_http_info(category, **kwargs)  # noqa: E501
            return data

    def get_fwots1_with_http_info(self, category, **kwargs):  # noqa: E501
        """Returns all the fwots paginated. If the connected user has an airline, the list is filtered for this airline  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_fwots1_with_http_info(category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: the category of the fwot (required)
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category', 'page', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fwots1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category' is set
        if ('category' not in params or
                params['category'] is None):
            raise ValueError("Missing the required parameter `category` when calling `get_fwots1`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/fwots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FwotV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ift(self, id, **kwargs):  # noqa: E501
        """updates (PUT) and/or returns(GET) the ift  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ift(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the ift ID (required)
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_ift_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ift_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_ift_with_http_info(self, id, **kwargs):  # noqa: E501
        """updates (PUT) and/or returns(GET) the ift  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ift_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the ift ID (required)
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ift" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ift`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/ifts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IftV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ifts(self, **kwargs):  # noqa: E501
        """Returns the ifts for faultcodes, layouts, parameters or robots  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ifts(async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: category of the IFT: faultcodes, layouts, parameters, robots
        :param str contains: a string contained by the formula
        :param int page: the page. starts #1
        :param int count: the max count of faultcodes
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_ifts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_ifts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_ifts_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the ifts for faultcodes, layouts, parameters or robots  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ifts_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: category of the IFT: faultcodes, layouts, parameters, robots
        :param str contains: a string contained by the formula
        :param int page: the page. starts #1
        :param int count: the max count of faultcodes
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category', 'contains', 'page', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ifts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/ifts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IftV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ifts1(self, category, **kwargs):  # noqa: E501
        """Returns the ifts for faultcodes, layouts, parameters or robots  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ifts1(category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: category of the IFT: faultcodes, layouts, parameters, robots (required)
        :param str contains: a string contained by the formula
        :param int page: the page. starts #1
        :param int count: the max count of faultcodes
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_ifts1_with_http_info(category, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ifts1_with_http_info(category, **kwargs)  # noqa: E501
            return data

    def get_ifts1_with_http_info(self, category, **kwargs):  # noqa: E501
        """Returns the ifts for faultcodes, layouts, parameters or robots  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ifts1_with_http_info(category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: category of the IFT: faultcodes, layouts, parameters, robots (required)
        :param str contains: a string contained by the formula
        :param int page: the page. starts #1
        :param int count: the max count of faultcodes
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category', 'contains', 'page', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ifts1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category' is set
        if ('category' not in params or
                params['category'] is None):
            raise ValueError("Missing the required parameter `category` when calling `get_ifts1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category' in params:
            path_params['category'] = params['category']  # noqa: E501

        query_params = []
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/ifts/{category}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IftV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_last_event(self, count, **kwargs):  # noqa: E501
        """all last events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_last_event(count, async=True)
        >>> result = thread.get()

        :param async bool
        :param int count: the max count of messages (required)
        :param str tags: the list of filtering tags
        :param str sev: the list of filtering severity
        :param bool dismissed: filter if dismissed or not dismissed or no filter if not set
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_last_event_with_http_info(count, **kwargs)  # noqa: E501
        else:
            (data) = self.get_last_event_with_http_info(count, **kwargs)  # noqa: E501
            return data

    def get_last_event_with_http_info(self, count, **kwargs):  # noqa: E501
        """all last events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_last_event_with_http_info(count, async=True)
        >>> result = thread.get()

        :param async bool
        :param int count: the max count of messages (required)
        :param str tags: the list of filtering tags
        :param str sev: the list of filtering severity
        :param bool dismissed: filter if dismissed or not dismissed or no filter if not set
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['count', 'tags', 'sev', 'dismissed']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_last_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'count' is set
        if ('count' not in params or
                params['count'] is None):
            raise ValueError("Missing the required parameter `count` when calling `get_last_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'count' in params:
            path_params['count'] = params['count']  # noqa: E501

        query_params = []
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
        if 'sev' in params:
            query_params.append(('sev', params['sev']))  # noqa: E501
        if 'dismissed' in params:
            query_params.append(('dismissed', params['dismissed']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/last/{count}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_last_fwot_event(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns the last event for a fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_last_fwot_event(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_last_fwot_event_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.get_last_fwot_event_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def get_last_fwot_event_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns the last event for a fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_last_fwot_event_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_last_fwot_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_last_fwot_event`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_last_fwot_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/last', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_layout(self, layout_id, **kwargs):  # noqa: E501
        """Returns a layout stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_layout(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_layout_with_http_info(layout_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_layout_with_http_info(layout_id, **kwargs)  # noqa: E501
            return data

    def get_layout_with_http_info(self, layout_id, **kwargs):  # noqa: E501
        """Returns a layout stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_layout_with_http_info(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['layout_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_layout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'layout_id' is set
        if ('layout_id' not in params or
                params['layout_id'] is None):
            raise ValueError("Missing the required parameter `layout_id` when calling `get_layout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'layout_id' in params:
            path_params['layoutId'] = params['layout_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/{layoutId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_layouts(self, **kwargs):  # noqa: E501
        """Returns list of layouts stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_layouts(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :param str contains: the layout name part to filter on
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_layouts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_layouts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_layouts_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of layouts stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_layouts_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :param str contains: the layout name part to filter on
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'count', 'contains']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_layouts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_layouts_layout_id_spider(self, layout_id, **kwargs):  # noqa: E501
        """Tunnels the layout EXT URL. If not an ExternalSourceLayout, returns a BAD REQUEST   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_layouts_layout_id_spider(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_layouts_layout_id_spider_with_http_info(layout_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_layouts_layout_id_spider_with_http_info(layout_id, **kwargs)  # noqa: E501
            return data

    def get_layouts_layout_id_spider_with_http_info(self, layout_id, **kwargs):  # noqa: E501
        """Tunnels the layout EXT URL. If not an ExternalSourceLayout, returns a BAD REQUEST   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_layouts_layout_id_spider_with_http_info(layout_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int layout_id: the id of the layout (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['layout_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_layouts_layout_id_spider" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'layout_id' is set
        if ('layout_id' not in params or
                params['layout_id'] is None):
            raise ValueError("Missing the required parameter `layout_id` when calling `get_layouts_layout_id_spider`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'layout_id' in params:
            path_params['layoutId'] = params['layout_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/{layoutId}/spider', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_login(self, username, tnc, **kwargs):  # noqa: E501
        """login to be authenticated  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_login(username, tnc, async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: the login to connect with. Is an email address (required)
        :param bool tnc: I do accept the terms and conditions (required)
        :param str password: the password to connect with
        :param bool remember: remember the connection information for 30 days
        :return: UserV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_login_with_http_info(username, tnc, **kwargs)  # noqa: E501
        else:
            (data) = self.get_login_with_http_info(username, tnc, **kwargs)  # noqa: E501
            return data

    def get_login_with_http_info(self, username, tnc, **kwargs):  # noqa: E501
        """login to be authenticated  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_login_with_http_info(username, tnc, async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: the login to connect with. Is an email address (required)
        :param bool tnc: I do accept the terms and conditions (required)
        :param str password: the password to connect with
        :param bool remember: remember the connection information for 30 days
        :return: UserV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'tnc', 'password', 'remember']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_login" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `get_login`")  # noqa: E501
        # verify the required parameter 'tnc' is set
        if ('tnc' not in params or
                params['tnc'] is None):
            raise ValueError("Missing the required parameter `tnc` when calling `get_login`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501
        if 'remember' in params:
            query_params.append(('remember', params['remember']))  # noqa: E501
        if 'tnc' in params:
            query_params.append(('tnc', params['tnc']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/login', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logout(self, **kwargs):  # noqa: E501
        """log out from the current session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logout(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ErrorDao
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logout_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_logout_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_logout_with_http_info(self, **kwargs):  # noqa: E501
        """log out from the current session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logout_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ErrorDao
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logout" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/logout', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDao',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_next_event(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the next events type as the given one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_next_event(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param int count: the count of returned messages
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_next_event_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_next_event_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def get_next_event_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the next events type as the given one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_next_event_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param int count: the count of returned messages
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_next_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_next_event`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_next_event`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_next_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/next', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_parameter(self, id, **kwargs):  # noqa: E501
        """returns a parameter. You can PUT or GET. DELETE not yet supported  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameter(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the parameters to filter on. (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_parameter_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_parameter_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_parameter_with_http_info(self, id, **kwargs):  # noqa: E501
        """returns a parameter. You can PUT or GET. DELETE not yet supported  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameter_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the parameters to filter on. (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parameter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_parameter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_parameter1(self, actype, name, **kwargs):  # noqa: E501
        """Returns the parameter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameter1(actype, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the fwot type. You will need either a actype or a reg for this request (required)
        :param str name: the name of the parameter (required)
        :param str category: the category of the fwot
        :param str reg: the fwot reg. You will need either a actype or a reg for this request
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_parameter1_with_http_info(actype, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_parameter1_with_http_info(actype, name, **kwargs)  # noqa: E501
            return data

    def get_parameter1_with_http_info(self, actype, name, **kwargs):  # noqa: E501
        """Returns the parameter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameter1_with_http_info(actype, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the fwot type. You will need either a actype or a reg for this request (required)
        :param str name: the name of the parameter (required)
        :param str category: the category of the fwot
        :param str reg: the fwot reg. You will need either a actype or a reg for this request
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['actype', 'name', 'category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parameter1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'actype' is set
        if ('actype' not in params or
                params['actype'] is None):
            raise ValueError("Missing the required parameter `actype` when calling `get_parameter1`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_parameter1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'actype' in params:
            path_params['actype'] = params['actype']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters/{actype}/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_parameter2(self, plural_category, reg, name, **kwargs):  # noqa: E501
        """Returns the parameter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameter2(plural_category, reg, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the fwot reg. You will need either a actype or a reg for this request (required)
        :param str name: the name of the parameter (required)
        :param str actype: the fwot type. You will need either a actype or a reg for this request
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_parameter2_with_http_info(plural_category, reg, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_parameter2_with_http_info(plural_category, reg, name, **kwargs)  # noqa: E501
            return data

    def get_parameter2_with_http_info(self, plural_category, reg, name, **kwargs):  # noqa: E501
        """Returns the parameter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameter2_with_http_info(plural_category, reg, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the fwot reg. You will need either a actype or a reg for this request (required)
        :param str name: the name of the parameter (required)
        :param str actype: the fwot type. You will need either a actype or a reg for this request
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'name', 'actype']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parameter2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_parameter2`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_parameter2`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_parameter2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'actype' in params:
            query_params.append(('actype', params['actype']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/parameters/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_parameters(self, **kwargs):  # noqa: E501
        """Returns the parameters for the given search string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameters(async=True)
        >>> result = thread.get()

        :param async bool
        :param str contains: the parameter name part to filter on
        :param bool detailled: Do we return the head (false&default) or the complete description?
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_parameters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_parameters_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_parameters_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the parameters for the given search string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameters_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str contains: the parameter name part to filter on
        :param bool detailled: Do we return the head (false&default) or the complete description?
        :param int page: the page. starts #1
        :param int count: the max count of parameter
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contains', 'detailled', 'page', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parameters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501
        if 'detailled' in params:
            query_params.append(('detailled', params['detailled']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_parameters1(self, actype, **kwargs):  # noqa: E501
        """Returns all parameters for an fwot type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameters1(actype, async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the fwot type (required)
        :param str name: the parameter names to filter on. May be null
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_parameters1_with_http_info(actype, **kwargs)  # noqa: E501
        else:
            (data) = self.get_parameters1_with_http_info(actype, **kwargs)  # noqa: E501
            return data

    def get_parameters1_with_http_info(self, actype, **kwargs):  # noqa: E501
        """Returns all parameters for an fwot type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parameters1_with_http_info(actype, async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the fwot type (required)
        :param str name: the parameter names to filter on. May be null
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['actype', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parameters1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'actype' is set
        if ('actype' not in params or
                params['actype'] is None):
            raise ValueError("Missing the required parameter `actype` when calling `get_parameters1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'actype' in params:
            path_params['actype'] = params['actype']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters/{actype}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_plural_category_reg_refresh(self, plural_category, reg, **kwargs):  # noqa: E501
        """refresh the cache of the fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_plural_category_reg_refresh(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_plural_category_reg_refresh_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.get_plural_category_reg_refresh_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def get_plural_category_reg_refresh_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """refresh the cache of the fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_plural_category_reg_refresh_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_plural_category_reg_refresh" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_plural_category_reg_refresh`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_plural_category_reg_refresh`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/refresh', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FwotV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_previous_event(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the previous events type as the given one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_previous_event(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param int count: the count of returned messages
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_previous_event_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_previous_event_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def get_previous_event_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """Returns the previous events type as the given one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_previous_event_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :param int count: the count of returned messages
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_previous_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_previous_event`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_previous_event`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_previous_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/prev', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_raw(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """returns the raw data for a message. empty string if not exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_raw(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_raw_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_raw_with_http_info(plural_category, reg, event_id, **kwargs)  # noqa: E501
            return data

    def get_raw_with_http_info(self, plural_category, reg, event_id, **kwargs):  # noqa: E501
        """returns the raw data for a message. empty string if not exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_raw_with_http_info(plural_category, reg, event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param int event_id: the id of the event (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_raw`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_raw`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_raw`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/events/{eventId}/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sample(self, sample_id, **kwargs):  # noqa: E501
        """Returns a sample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_sample(sample_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int sample_id: the id of the sample (required)
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_sample_with_http_info(sample_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sample_with_http_info(sample_id, **kwargs)  # noqa: E501
            return data

    def get_sample_with_http_info(self, sample_id, **kwargs):  # noqa: E501
        """Returns a sample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_sample_with_http_info(sample_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int sample_id: the id of the sample (required)
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sample_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sample" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sample_id' is set
        if ('sample_id' not in params or
                params['sample_id'] is None):
            raise ValueError("Missing the required parameter `sample_id` when calling `get_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'sample_id' in params:
            path_params['sampleId'] = params['sample_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/samples/{sampleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_samples(self, **kwargs):  # noqa: E501
        """Returns list of samples stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples(async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: the category of the fwot
        :param str reg: if reg is null or empty, will be all the fwots
        :param str actype: fwot type
        :param str name: the parameter name. May be several
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param str format: json or csv or tsv
        :param bool chronological: if false: from newest to oldest
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_samples_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_samples_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_samples_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of samples stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: the category of the fwot
        :param str reg: if reg is null or empty, will be all the fwots
        :param str actype: fwot type
        :param str name: the parameter name. May be several
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param str format: json or csv or tsv
        :param bool chronological: if false: from newest to oldest
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category', 'reg', 'actype', 'name', '_from', 'to', 'page', 'count', 'with_invalid', 'format', 'chronological']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_samples" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'actype' in params:
            query_params.append(('actype', params['actype']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'with_invalid' in params:
            query_params.append(('withInvalid', params['with_invalid']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'chronological' in params:
            query_params.append(('chronological', params['chronological']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/samples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_samples1(self, actype, name, **kwargs):  # noqa: E501
        """Returns a sample csv table as required in dygraphs for the fwot type. It can be filtered on filter parameter values.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples1(actype, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the type of fwot (required)
        :param str name: the parameter name (required)
        :param str filter_name: the parameter name used to filter
        :param str filter_value: the parameter name used to filter
        :param str format: json or csv or tsv
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param int count: the max count of messages
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_samples1_with_http_info(actype, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_samples1_with_http_info(actype, name, **kwargs)  # noqa: E501
            return data

    def get_samples1_with_http_info(self, actype, name, **kwargs):  # noqa: E501
        """Returns a sample csv table as required in dygraphs for the fwot type. It can be filtered on filter parameter values.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples1_with_http_info(actype, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str actype: the type of fwot (required)
        :param str name: the parameter name (required)
        :param str filter_name: the parameter name used to filter
        :param str filter_value: the parameter name used to filter
        :param str format: json or csv or tsv
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param int count: the max count of messages
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['actype', 'name', 'filter_name', 'filter_value', 'format', '_from', 'to', 'with_invalid', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_samples1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'actype' is set
        if ('actype' not in params or
                params['actype'] is None):
            raise ValueError("Missing the required parameter `actype` when calling `get_samples1`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_samples1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'actype' in params:
            path_params['actype'] = params['actype']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'filter_name' in params:
            query_params.append(('filterName', params['filter_name']))  # noqa: E501
        if 'filter_value' in params:
            query_params.append(('filterValue', params['filter_value']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'with_invalid' in params:
            query_params.append(('withInvalid', params['with_invalid']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters/{actype}/{name}/samples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_samples2(self, plural_category, reg, name, **kwargs):  # noqa: E501
        """Returns list of samples stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples2(plural_category, reg, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: if reg is null or empty, will be all the fwots (required)
        :param str name: the parameter name. May be several (required)
        :param str actype: fwot type
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param str format: json or csv or tsv
        :param bool chronological: if false: from newest to oldest
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_samples2_with_http_info(plural_category, reg, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_samples2_with_http_info(plural_category, reg, name, **kwargs)  # noqa: E501
            return data

    def get_samples2_with_http_info(self, plural_category, reg, name, **kwargs):  # noqa: E501
        """Returns list of samples stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples2_with_http_info(plural_category, reg, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: if reg is null or empty, will be all the fwots (required)
        :param str name: the parameter name. May be several (required)
        :param str actype: fwot type
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param str format: json or csv or tsv
        :param bool chronological: if false: from newest to oldest
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'name', 'actype', '_from', 'to', 'page', 'count', 'with_invalid', 'format', 'chronological']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_samples2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_samples2`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_samples2`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_samples2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'actype' in params:
            query_params.append(('actype', params['actype']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'with_invalid' in params:
            query_params.append(('withInvalid', params['with_invalid']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'chronological' in params:
            query_params.append(('chronological', params['chronological']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/samples/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_samples3(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns list of samples stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples3(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: if reg is null or empty, will be all the fwots (required)
        :param str actype: fwot type
        :param str name: the parameter name. May be several
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param str format: json or csv or tsv
        :param bool chronological: if false: from newest to oldest
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_samples3_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.get_samples3_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def get_samples3_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """Returns list of samples stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_samples3_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: if reg is null or empty, will be all the fwots (required)
        :param str actype: fwot type
        :param str name: the parameter name. May be several
        :param datetime _from: the date from which we want to get the samples
        :param datetime to: the date to which we want to get the samples
        :param int page: the page. starts #1
        :param int count: the max count of messages
        :param bool with_invalid: default/false: include not VALID state samples. true -> include them
        :param str format: json or csv or tsv
        :param bool chronological: if false: from newest to oldest
        :return: SampleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'actype', 'name', '_from', 'to', 'page', 'count', 'with_invalid', 'format', 'chronological']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_samples3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `get_samples3`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `get_samples3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []
        if 'actype' in params:
            query_params.append(('actype', params['actype']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'with_invalid' in params:
            query_params.append(('withInvalid', params['with_invalid']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'chronological' in params:
            query_params.append(('chronological', params['chronological']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/samples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SampleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_stats(self, **kwargs):  # noqa: E501
        """fetches some statistics on the running server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_stats(async=True)
        >>> result = thread.get()

        :param async bool
        :param datetime _from: the computed date from which we want to get the events
        :param datetime to: the computed date to which we want to get the events
        :return: StatsV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_stats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_stats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_stats_with_http_info(self, **kwargs):  # noqa: E501
        """fetches some statistics on the running server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_stats_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param datetime _from: the computed date from which we want to get the events
        :param datetime to: the computed date to which we want to get the events
        :return: StatsV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['_from', 'to']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatsV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_status(self, **kwargs):  # noqa: E501
        """check the status of the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_status_with_http_info(self, **kwargs):  # noqa: E501
        """check the status of the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_symbol(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_symbol(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
            return data

    def get_symbol_with_http_info(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_symbol_with_http_info(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_symbol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol_id' is set
        if ('symbol_id' not in params or
                params['symbol_id'] is None):
            raise ValueError("Missing the required parameter `symbol_id` when calling `get_symbol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'symbol_id' in params:
            path_params['symbolId'] = params['symbol_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols/{symbolId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_symbol_svg_example(self, symbol_id, **kwargs):  # noqa: E501
        """Returns the SVG example for a symbol  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_symbol_svg_example(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_symbol_svg_example_with_http_info(symbol_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_symbol_svg_example_with_http_info(symbol_id, **kwargs)  # noqa: E501
            return data

    def get_symbol_svg_example_with_http_info(self, symbol_id, **kwargs):  # noqa: E501
        """Returns the SVG example for a symbol  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_symbol_svg_example_with_http_info(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_symbol_svg_example" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol_id' is set
        if ('symbol_id' not in params or
                params['symbol_id'] is None):
            raise ValueError("Missing the required parameter `symbol_id` when calling `get_symbol_svg_example`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'symbol_id' in params:
            path_params['symbolId'] = params['symbol_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols/{symbolId}/svgExample', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_terms_and_conditions(self, **kwargs):  # noqa: E501
        """returns the HTML for the terms and conditions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_terms_and_conditions(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_terms_and_conditions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_terms_and_conditions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_terms_and_conditions_with_http_info(self, **kwargs):  # noqa: E501
        """returns the HTML for the terms and conditions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_terms_and_conditions_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_terms_and_conditions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/TnCs.html', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_trend(self, bundle_id, **kwargs):  # noqa: E501
        """get, update or delete a trend  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trend(bundle_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bundle_id: the id of the bundle (required)
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_trend_with_http_info(bundle_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_trend_with_http_info(bundle_id, **kwargs)  # noqa: E501
            return data

    def get_trend_with_http_info(self, bundle_id, **kwargs):  # noqa: E501
        """get, update or delete a trend  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trend_with_http_info(bundle_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bundle_id: the id of the bundle (required)
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bundle_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trend" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bundle_id' is set
        if ('bundle_id' not in params or
                params['bundle_id'] is None):
            raise ValueError("Missing the required parameter `bundle_id` when calling `get_trend`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bundle_id' in params:
            path_params['bundleId'] = params['bundle_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/trendbundles/{bundleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrendBundleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_trends(self, **kwargs):  # noqa: E501
        """Returns list of trends stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trends(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_trends_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_trends_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_trends_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of trends stored in WILCO  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trends_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trends" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/trendbundles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrendBundleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, **kwargs):  # noqa: E501
        """Returns profile of the current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user(async=True)
        >>> result = thread.get()

        :param async bool
        :return: UserV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_user_with_http_info(self, **kwargs):  # noqa: E501
        """Returns profile of the current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: UserV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, **kwargs):  # noqa: E501
        """fetches the list of users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users(async=True)
        >>> result = thread.get()

        :param async bool
        :return: UserV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_users_with_http_info(self, **kwargs):  # noqa: E501
        """fetches the list of users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: UserV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_acars(self, **kwargs):  # noqa: E501
        """posts some raw data. if the decoder is not passed, then they are tried to find the first matching one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_acars(async=True)
        >>> result = thread.get()

        :param async bool
        :param str parser_name: the name of the parser
        :param str webhook: if defined, the query returns immediately and calls the webhook when finished with the event as JSON
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_acars_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_acars_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_acars_with_http_info(self, **kwargs):  # noqa: E501
        """posts some raw data. if the decoder is not passed, then they are tried to find the first matching one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_acars_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str parser_name: the name of the parser
        :param str webhook: if defined, the query returns immediately and calls the webhook when finished with the event as JSON
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['parser_name', 'webhook']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_acars" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parser_name' in params:
            query_params.append(('parserName', params['parser_name']))  # noqa: E501
        if 'webhook' in params:
            query_params.append(('webhook', params['webhook']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/acars', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_acars_parser_name(self, parser_name, **kwargs):  # noqa: E501
        """posts some raw data. if the decoder is not passed, then they are tried to find the first matching one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_acars_parser_name(parser_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str parser_name: the name of the parser (required)
        :param str webhook: if defined, the query returns immediately and calls the webhook when finished with the event as JSON
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_acars_parser_name_with_http_info(parser_name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_acars_parser_name_with_http_info(parser_name, **kwargs)  # noqa: E501
            return data

    def post_acars_parser_name_with_http_info(self, parser_name, **kwargs):  # noqa: E501
        """posts some raw data. if the decoder is not passed, then they are tried to find the first matching one  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_acars_parser_name_with_http_info(parser_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str parser_name: the name of the parser (required)
        :param str webhook: if defined, the query returns immediately and calls the webhook when finished with the event as JSON
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['parser_name', 'webhook']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_acars_parser_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'parser_name' is set
        if ('parser_name' not in params or
                params['parser_name'] is None):
            raise ValueError("Missing the required parameter `parser_name` when calling `post_acars_parser_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'parser_name' in params:
            path_params['parserName'] = params['parser_name']  # noqa: E501

        query_params = []
        if 'webhook' in params:
            query_params.append(('webhook', params['webhook']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/acars/{parserName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_insert_message(self, **kwargs):  # noqa: E501
        """interface to update a message with the WILCO format. Deprecated. Use PUT:event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.put_insert_message(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.put_insert_message_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.put_insert_message_with_http_info(**kwargs)  # noqa: E501
            return data

    def put_insert_message_with_http_info(self, **kwargs):  # noqa: E501
        """interface to update a message with the WILCO format. Deprecated. Use PUT:event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.put_insert_message_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_insert_message" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/insertMessage', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_batch_reprocess(self, event_id, **kwargs):  # noqa: E501
        """allows to reprocess all the events with the same layout. It deletes and recreates the matching messages, samples and analysis. THIS CAN BE VEEERRY LONG and DANGEROUS. It processes the last week only taking the event date as ref date  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_batch_reprocess(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_batch_reprocess_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_batch_reprocess_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def update_batch_reprocess_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """allows to reprocess all the events with the same layout. It deletes and recreates the matching messages, samples and analysis. THIS CAN BE VEEERRY LONG and DANGEROUS. It processes the last week only taking the event date as ref date  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_batch_reprocess_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_batch_reprocess" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `update_batch_reprocess`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/reprocess/batch', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard(self, id, skip_symbols, **kwargs):  # noqa: E501
        """modifies the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard(id, skip_symbols, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the dashboard (required)
        :param bool skip_symbols: do not update symbols (required)
        :return: DashboardV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dashboard_with_http_info(id, skip_symbols, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_with_http_info(id, skip_symbols, **kwargs)  # noqa: E501
            return data

    def update_dashboard_with_http_info(self, id, skip_symbols, **kwargs):  # noqa: E501
        """modifies the dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_with_http_info(id, skip_symbols, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the dashboard (required)
        :param bool skip_symbols: do not update symbols (required)
        :return: DashboardV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'skip_symbols']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_dashboard`")  # noqa: E501
        # verify the required parameter 'skip_symbols' is set
        if ('skip_symbols' not in params or
                params['skip_symbols'] is None):
            raise ValueError("Missing the required parameter `skip_symbols` when calling `update_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'skip_symbols' in params:
            query_params.append(('skipSymbols', params['skip_symbols']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_rule(self, dbid, id, **kwargs):  # noqa: E501
        """modifies the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_rule(dbid, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :param int id: the id of the dashboard rule (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dashboard_rule_with_http_info(dbid, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_rule_with_http_info(dbid, id, **kwargs)  # noqa: E501
            return data

    def update_dashboard_rule_with_http_info(self, dbid, id, **kwargs):  # noqa: E501
        """modifies the dashboard rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_rule_with_http_info(dbid, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dbid: the id of the dashboard (required)
        :param int id: the id of the dashboard rule (required)
        :return: RuleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dbid', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dbid' is set
        if ('dbid' not in params or
                params['dbid'] is None):
            raise ValueError("Missing the required parameter `dbid` when calling `update_dashboard_rule`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_dashboard_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dbid' in params:
            path_params['dbid'] = params['dbid']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/dashboards/{dbid}/rules/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_symbols(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_symbols(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_symbols_with_http_info(**kwargs)  # noqa: E501
            return data

    def update_dashboard_symbols_with_http_info(self, **kwargs):  # noqa: E501
        """Returns all the dashboard symbols  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_symbols_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_symbols" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event(self, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def update_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Returns an event from the ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str category: the category of the fwot
        :param str reg: the registration of the fwot
        :param bool nested: do we create a nested JSON (samples+A/C+...)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'category', 'reg', 'nested']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `update_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'reg' in params:
            query_params.append(('reg', params['reg']))  # noqa: E501
        if 'nested' in params:
            query_params.append(('nested', params['nested']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_fwot(self, plural_category, reg, **kwargs):  # noqa: E501
        """Updates the fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_fwot(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_fwot_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.update_fwot_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def update_fwot_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """Updates the fwot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_fwot_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_fwot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `update_fwot`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `update_fwot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FwotV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_fwot_position(self, plural_category, reg, **kwargs):  # noqa: E501
        """sets the fwot position  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_fwot_position(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param str reg_log: the reg of a fwot that has lat/lon
        :param float lat: the lat of the fwot
        :param float lon: the lon of the fwot
        :param float alt: the alt of the fwot
        :param datetime date: the pos date of the fwot
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_fwot_position_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
        else:
            (data) = self.update_fwot_position_with_http_info(plural_category, reg, **kwargs)  # noqa: E501
            return data

    def update_fwot_position_with_http_info(self, plural_category, reg, **kwargs):  # noqa: E501
        """sets the fwot position  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_fwot_position_with_http_info(plural_category, reg, async=True)
        >>> result = thread.get()

        :param async bool
        :param str plural_category: the category of the fwot (required)
        :param str reg: the registration of the fwot (required)
        :param str reg_log: the reg of a fwot that has lat/lon
        :param float lat: the lat of the fwot
        :param float lon: the lon of the fwot
        :param float alt: the alt of the fwot
        :param datetime date: the pos date of the fwot
        :return: FwotV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['plural_category', 'reg', 'reg_log', 'lat', 'lon', 'alt', 'date']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_fwot_position" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'plural_category' is set
        if ('plural_category' not in params or
                params['plural_category'] is None):
            raise ValueError("Missing the required parameter `plural_category` when calling `update_fwot_position`")  # noqa: E501
        # verify the required parameter 'reg' is set
        if ('reg' not in params or
                params['reg'] is None):
            raise ValueError("Missing the required parameter `reg` when calling `update_fwot_position`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plural_category' in params:
            path_params['pluralCategory'] = params['plural_category']  # noqa: E501
        if 'reg' in params:
            path_params['reg'] = params['reg']  # noqa: E501

        query_params = []
        if 'reg_log' in params:
            query_params.append(('regLog', params['reg_log']))  # noqa: E501
        if 'lat' in params:
            query_params.append(('lat', params['lat']))  # noqa: E501
        if 'lon' in params:
            query_params.append(('lon', params['lon']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/{pluralCategory}/{reg}/location', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FwotV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ift(self, id, **kwargs):  # noqa: E501
        """updates (PUT) and/or returns(GET) the ift  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ift(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the ift ID (required)
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ift_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ift_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_ift_with_http_info(self, id, **kwargs):  # noqa: E501
        """updates (PUT) and/or returns(GET) the ift  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ift_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the ift ID (required)
        :return: IftV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ift" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_ift`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/ifts/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IftV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_parameter(self, id, **kwargs):  # noqa: E501
        """returns a parameter. You can PUT or GET. DELETE not yet supported  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_parameter(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the parameters to filter on. (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_parameter_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_parameter_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_parameter_with_http_info(self, id, **kwargs):  # noqa: E501
        """returns a parameter. You can PUT or GET. DELETE not yet supported  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_parameter_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: the id of the parameters to filter on. (required)
        :return: ParameterV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_parameter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_parameter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/parameters/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParameterV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_reprocess(self, event_id, **kwargs):  # noqa: E501
        """allows to reprocess the event. It deletes the message, samples and analysis and recomputes it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_reprocess(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_reprocess_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_reprocess_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def update_reprocess_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """allows to reprocess the event. It deletes the message, samples and analysis and recomputes it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_reprocess_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_reprocess" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `update_reprocess`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/reprocess', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_symbol(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_symbol(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_symbol_with_http_info(symbol_id, **kwargs)  # noqa: E501
            return data

    def update_symbol_with_http_info(self, symbol_id, **kwargs):  # noqa: E501
        """Returns/create/updates all the dashboard symbols. to delete a symbol function, empty its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_symbol_with_http_info(symbol_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int symbol_id: the id of the symbol (required)
        :return: DashboardSymbolV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_symbol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol_id' is set
        if ('symbol_id' not in params or
                params['symbol_id'] is None):
            raise ValueError("Missing the required parameter `symbol_id` when calling `update_symbol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'symbol_id' in params:
            path_params['symbolId'] = params['symbol_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/symbols/{symbolId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardSymbolV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_tag(self, event_id, tag, **kwargs):  # noqa: E501
        """tags an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_tag(event_id, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str tag: the tag to set (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_tag_with_http_info(event_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.update_tag_with_http_info(event_id, tag, **kwargs)  # noqa: E501
            return data

    def update_tag_with_http_info(self, event_id, tag, **kwargs):  # noqa: E501
        """tags an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_tag_with_http_info(event_id, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str tag: the tag to set (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'tag']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `update_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `update_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/tag', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_trend(self, bundle_id, **kwargs):  # noqa: E501
        """get, update or delete a trend  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_trend(bundle_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bundle_id: the id of the bundle (required)
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_trend_with_http_info(bundle_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_trend_with_http_info(bundle_id, **kwargs)  # noqa: E501
            return data

    def update_trend_with_http_info(self, bundle_id, **kwargs):  # noqa: E501
        """get, update or delete a trend  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_trend_with_http_info(bundle_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int bundle_id: the id of the bundle (required)
        :return: TrendBundleV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bundle_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_trend" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bundle_id' is set
        if ('bundle_id' not in params or
                params['bundle_id'] is None):
            raise ValueError("Missing the required parameter `bundle_id` when calling `update_trend`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bundle_id' in params:
            path_params['bundleId'] = params['bundle_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/trendbundles/{bundleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrendBundleV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_un_tag(self, event_id, tag, **kwargs):  # noqa: E501
        """untags an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_un_tag(event_id, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str tag: the tag to remove (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_un_tag_with_http_info(event_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.update_un_tag_with_http_info(event_id, tag, **kwargs)  # noqa: E501
            return data

    def update_un_tag_with_http_info(self, event_id, tag, **kwargs):  # noqa: E501
        """untags an event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_un_tag_with_http_info(event_id, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: the id of the event (required)
        :param str tag: the tag to remove (required)
        :return: EventV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'tag']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_un_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `update_un_tag`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `update_un_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/events/{eventId}/untag', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_webhook(self, webhook_id, **kwargs):  # noqa: E501
        """endpoint for push layouts webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_webhook(webhook_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str webhook_id: the uuid of the hook (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501
            return data

    def update_webhook_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        """endpoint for push layouts webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_webhook_with_http_info(webhook_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str webhook_id: the uuid of the hook (required)
        :return: LayoutV3IO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['webhook_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_webhook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'webhook_id' is set
        if ('webhook_id' not in params or
                params['webhook_id'] is None):
            raise ValueError("Missing the required parameter `webhook_id` when calling `update_webhook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'webhook_id' in params:
            path_params['webhookId'] = params['webhook_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key_header', 'api_key_param']  # noqa: E501

        return self.api_client.call_api(
            '/apiv3/layouts/webhook/{webhookId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LayoutV3IO',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
